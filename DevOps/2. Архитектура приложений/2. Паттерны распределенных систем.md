# Урок 2. Паттерны распределенных систем

1. Разделение ответственности команд и запросов (CQRS)
2. Двухфазная фиксация (2PC)
3. Saga
4. Реплицированные службы с балансировкой нагрузки (RLBS)
5. Сегментированные (шардированные) сервисы (sharded services)
# Разделение ответственности команд и запросов (CQRS)

На прошлом уроке вы уже познакомились с разделением ответственности команд и запросов  (CQRS). Остановимся на реализации этого паттерна в распределенных системах.

CQRS — это подход к проектированию системы, при котором операции записи (команды) и операции чтения (запросы) разделены на разные модели, что позволяет улучшить масштабируемость и производительность системы.

![](file:///C:/Users/afana/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

|   |   |
|---|---|
|**Плюсы**<br><br>●       Снижение сложности системы за счет делегирования задач.<br><br>●       Четкое разделение между бизнес-логикой и валидацией.<br><br>●       Легкая классификация процессов по принципу работы.<br><br>●       Сокращение количества неожиданных изменений в общих данных.<br><br>●       Уменьшение количества сущностей, которые имеют доступ к изменению данных.|**Минусы**<br><br>●       Необходимость поддерживать постоянную обратную связь между командами и моделями чтения.<br><br>●       Увеличение задержки при отправке запросов с высокой пропускной способностью.<br><br>●       Отсутствие средств для связи между сервисными процессами.|

В распределенной архитектуре система состоит из нескольких узлов, каждый из которых может иметь свою локальную копию данных.

CQRS позволяет улучшить производительность системы, ведь запросы могут быть обработаны локально, без необходимости обращаться к другим узлам или централизованной базе данных.

В тоже время в распределенной архитектуре применение этого паттерна может повлечь за собой дополнительную сложность, связанную с согласованием изменений между узлами.

_Например: если одна команда влияет на несколько узлов, необходимо обеспечить согласованность изменений между ними._

Эта проблема может быть решена путем использования **механизмов распределенной транзакционности**, таких как 2PC, или или с помощью **асинхронной обработки команд с использованием очередей сообщений**.

Иными словами, CQRS может быть полезным в распределенной архитектуре, позволяя улучшить масштабируемость и производительность системы, однако, это требует дополнительной работы по обеспечению согласованности изменений между узлами.

# Двухфазная фиксация (2PC)

2PC (Two-Phase Commit) — это паттерн распределенной транзакционности, который обеспечивает согласованность изменений в распределенной системе.

![](file:///C:/Users/afana/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

Как это работает:

1. Фаза подготовки (Preparation Phase).

Координатор (Coordinator) отправляет запрос на подготовку (Prepare) к каждому участнику транзакции. Каждый участник выполняет операцию и готовится к фиксации изменений в случае получения сигнала от координатора.

2. Фаза фиксации (Commit Phase).

Координатор отправляет запрос на фиксацию (Commit) к каждому участнику. Если все участники успешно выполнили фазу подготовки, они фиксируют свои изменения и отправляют подтверждение координатору.

3. Фаза отката (Abort Phase).

Если хотя бы один участник не может выполнить фазу подготовки или фиксации, координатор отправляет запрос на откат (Abort) к каждому участнику, и все изменения откатываются.

|   |   |
|---|---|
|**Плюсы**<br><br>●       Устойчивость к ошибкам из-за отсутствия одновременных запросов.<br><br>●       Отличная масштабируемость — возможность обрабатывать огромные объемы данных.<br><br>●       Изоляция и обмен данными одновременно.|**Минусы**<br><br>●       Подверженность узким местам и блокировкам из-за синхронности.<br><br>●       Потребность в большем количестве ресурсов, чем другие шаблоны проектирования.|

В распределенной архитектуре 2PC может быть использован для **обеспечения согласованности изменений между узлами**. Однако, 2PC имеет некоторые недостатки, которые могут снижать производительность системы, например, блокировки могут привести к длительному ожиданию ответов от других участников транзакции, что может привести к замедлению системы. Кроме того, отказ одного из участников может привести к блокировке транзакции и недоступности ресурсов до момента разрешения проблемы.

2PC рекомендуется использовать только в случае, если другие механизмы обеспечения согласованности не могут быть использованы или если участники транзакции находятся в разных доменах безопасности и необходимо обеспечить атомарность изменений между ними.

# SAGA

**SAGA** — это паттерн распределенной транзакционности, которая используется для обеспечения согласованности изменений в распределенных системах. Он работает по принципу последовательности локальных транзакций, которые выполняются участниками транзакции.

![](file:///C:/Users/afana/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)

В отличие от 2PC в SAGA используются компенсирующие операции для отмены предыдущих изменений, если текущая транзакция не может быть завершена.

Паттерн состоит из следующих компонентов:

●       Сага-оркестратор (Saga Orchestrator). Координирует выполнение всех локальных транзакций, и определяет порядок их выполнения.

●       Локальная транзакция (Local Transaction). Каждый участник транзакции выполняет свою локальную транзакцию, которая может быть подтверждена или отменена.

●       Компенсирующая операция (Compensating Operation). Если локальная транзакция не может быть завершена, участник выполняет компенсирующую операцию, которая отменяет предыдущие изменения.

|   |   |
|---|---|
|**Плюсы**<br><br>●       Отдельные сервисы могут обрабатывать гораздо более длительные транзакции.<br><br>●       Подходит для распределенной системы из-за децентрализации.<br><br>●       Устраняет узкие места благодаря одноранговой связи между службами.|**Минусы**<br><br>●       Затрудняет отслеживание того, какие службы выполняют отдельные задачи.<br><br>●       Оркестровка становится сложнее, а отдельные сервисы менее изолированы друг от друга.|

SAGA может быть использован для обеспечения согласованности изменений между узлами в распределенных системах. Он может быть особенно полезен, если участники транзакции находятся в разных доменах безопасности или если общение между ними ненадежно.

Например, приложение имеет несколько сервисов, каждый из которых выполняет локальную транзакцию. SAGA-оркестратор управляет выполнением каждой локальной транзакции и, если какая-то из них не может быть завершена, участник выполняет компенсирующую операцию, которая отменяет предыдущие изменения. В результате, SAGA позволяет обеспечить согласованность изменений между сервисами, даже если общение между ними ненадежно или если участники находятся в разных доменах безопасности.

Однако, SAGA также имеет некоторые ограничения. В частности, он может быть сложным для реализации и управления, особенно в случае большого количества локальных транзакций. Кроме того, компенсирующие операции могут привести к нежелательным побочным эффектам, если они не выполняются правильно.

Кроме того, SAGA может быть неэффективным решением, если транзакции в системе имеют сложные зависимости или требуют длительного времени выполнения. В этом случае SAGA может потребовать больших ресурсов и замедлить работу системы.

Таким образом SAGA является паттерном транзакционности с определенными ограничениями и не всегда подходит для всех задач. При выборе подходящего паттерна транзакционности необходимо учитывать специфику конкретного приложения и его требования к согласованности изменений.

# Реплицированные службы с балансировкой нагрузки (RLBS)

Реплицированные службы с балансировкой нагрузки (RLBS) — это архитектурный паттерн, который используется для обеспечения высокой доступности и масштабируемости в распределенных системах.

![](file:///C:/Users/afana/AppData/Local/Temp/msohtmlclip1/01/clip_image008.gif)

Он предполагает наличие нескольких реплик серверов, которые работают в совместной группе для обработки запросов от клиентов. Каждая реплика сервера может принимать запросы от клиентов, а затем распределять их на другие реплики серверов в группе. При этом реплики серверов могут быть разнесены на разные физические узлы сети, что позволяет увеличить отказоустойчивость системы.

Для обеспечения балансировки нагрузки между репликами серверов, используется **механизм балансировки нагрузки (load balancing)**.

Этот механизм может быть реализован различными способами, например, с помощью Round Robin DNS, аппаратного балансировщика или программного балансировщика на основе алгоритмов балансировки.

|   |   |
|---|---|
|**Плюсы**<br><br>●       Стабильная производительность с точки зрения конечного пользователя.<br><br>●       Быстрое восстановление сервиса после отказа.<br><br>●       Высокая масштабируемость с большим количеством сервисов.<br><br>●       Высокий уровень параллелизма.|**Минусы**<br><br>●       Недостаточно производителен из-за алгоритма балансировки нагрузки.<br><br>●       Требует много ресурсов для управления сервисами.|

Одним из преимуществ паттерна является возможность масштабирования системы путем добавления новых реплик серверов.

При этом важно обеспечить согласованность данных между репликами серверов. Для этого могут использоваться различные механизмы репликации данных, например, механизмы репликации на основе журнала транзакций или репликации на основе снимков.

В целом, RLBS является эффективным паттерном для обеспечения высокой доступности и масштабируемости в распределенных системах. Однако, чтобы выбрать наиболее подходящий механизм репликации и балансировки нагрузки, необходимо учитывать специфику конкретной системы и требования к согласованности данных.

# Сегментированные сервисы (sharded services)

Сегментированные сервисы — это паттерн распределенной архитектуры, который используется для масштабирования служб, хранящих большое количество данных.

Он основан на разделении (шардировании) данных на несколько частей (шардов), которые затем могут быть обработаны параллельно на разных узлах в распределенной системе.

![](file:///C:/Users/afana/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)

Каждый шард может быть независимым сервисом, который обрабатывает запросы от клиентов и хранит свою часть данных.

Для обеспечения балансировки нагрузки между шардами используется механизм шардирования, который может быть реализован различными способами, например, на основе хеш-функций или диапазонов значений.

Для обеспечения согласованности данных между шардами используется механизм репликации данных, аналогичный упомянутому выше.

|   |   |
|---|---|
|**Плюсы**<br><br>●       Возможность масштабировать сегменты для общих запросов.<br><br>●       Легкая приоритизация запросов.<br><br>●       Простая отладка благодаря естественной сортировке.|**Минусы**<br><br>●       Поддержка большого числа сегментов может потребовать много ресурсов.<br><br>●       Непропорциональное использование сегментов может привести к потерям производительности.|

Одним из преимуществ этого паттерна является возможность масштабирования системы путем добавления новых шардов. При этом для обеспечения эффективной работы механизма шардирования важно учитывать ограничения на максимальное количество шардов в системе.

Кроме того, нельзя забывать и про специфику конкретной системы и требования к согласованности данных. Например, при работе с транзакционными данными может быть необходимо обеспечить согласованность изменений между различными шардами. В этом случае могут использоваться 2PC или SAGA.

В целом, паттерн является достаточно эффективным для масштабирования служб, хранящих большое количество данных. Однако для обеспечения высокой производительности и согласованности данных в распределенной системе необходимо тщательно планировать и реализовывать механизм шардирования и репликации данных.

# Подведем итоги

●       CQRS — это подход к проектированию системы, при котором операции записи (команды) и операции чтения (запросы) разделены на разные модели, что позволяет улучшить масштабируемость и производительность системы.

●       2PC (Two-Phase Commit) — это паттерн распределенной транзакционности, который обеспечивает согласованность изменений в распределенной системе.

●       SAGA — это паттерн распределенной транзакционности, которая используется для обеспечения согласованности изменений в распределенных системах. Он работает по принципу последовательности локальных транзакций, которые выполняются участниками транзакции.

●       Реплицированные службы с балансировкой нагрузки (RLBS) — это архитектурный паттерн, который используется для обеспечения высокой доступности и масштабируемости в распределенных системах.

●       Сегментированные сервисы — это паттерн распределенной архитектуры, основанный на разделении (шардировании) данных на несколько частей (шардов), которые затем могут быть обработаны параллельно на разных узлах в распределенной системе.