# Урок 2. Микросервисный подход при разработке сервисов

1. Что такое микросервисная архитектура
2. Чем микросервисные приложения отличаются от монолитов
3. В чем плюсы и минусы микросервисной архитектуры
4. Что относится к ключевым технологиям микросервисов
# Микросервисная архитектура

Микросервисная архитектура — это способ создания программных продуктов, предполагающий разработку независимых друг от друга модулей. Каждая часть приложения отвечает за определенную задачу и может быть изменена или расширена без дополнений в других. Сервисы взаимодействуют между собой с помощью обмена сообщениями. 

Иными словами, микросервисная архитектура предполагает разделение одного большого сервиса на несколько кусочков, где каждый логический юнит старого сервиса будет представлять отдельный микросервис нового. Поскольку теперь части приложения являются разными сервисами, встает вопрос их взаимодействия. Если раньше это был вызов метода или функции в одном большом приложении, теперь они должны обмениваться сообщениями, запуская методы или функции друг у друга удаленно. Для этого у каждого из них есть стандартизированное API, которое подразумевает прием и передачу межсервисных сообщений по стандартным каналам.

# Микросервисы или монолит?

![[Pasted image 20241010181158.png]]

Давайте посмотрим, чем отличаются эти подходы.

**Монолит** — традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Монолитом часто называют нечто большое и неповоротливое, и эти два слова хорошо описывают монолитную архитектуру для проектирования ПО.

В противовес ему существует современный микросервисный подход. Архитектура микросервисов состоит из независимо работающих модулей, каждую службу можно разрабатывать, обновлять, развертывать и масштабировать отдельно от остальных. Это позволяет чаще выполнять обновления, повышая надежность, время бесперебойной работы и производительность программного обеспечения. Если раньше мы выпускали обновления раз в неделю, то с микросервисной архитектурой делаем это до двух-трех раз в день.

Разберем отличия монолита и микросервисов на примере:

●       Монолитный интернет-магазин. Все компоненты в одном: витрина продуктов, корзина и система оплаты. Логический слой — бэкенд сайта. В нем же реализована логика доступа к данным. Одна база данных.

●       Интернет-магазин на микросервисах. Приложение разбито на несколько фронт-микросервисов, каждый из которых отвечает за свой логический участок. У каждого из них свой бэкенд с логикой, в котором они обмениваются сообщениями. Базы данных разделены.

# Свойства микросервиса

**Компактность.** Микросервис — это маленькая программа

**Разделение ответственности.** Микросервис выполняет только единственную задачу и не залезает в ответственность других микросервисов.

**Независимость.** Микросервис слабо связан с другими микросервисами (только если это не Data Layer)

**Простота и ясность интерфейсов.** В микросервисах используются стандартные API и стандартные протоколы взаимодействия. Это удобно, быстро работает, увеличивает скорость разработки и интеграции.

**Микросервис в большей мере Stateless, чем Stateful.** Микросервисы не сохраняют свое состояние или какие-то данные в процессе работы. Это простые веб- и API-сервисы, что довольно эффективно в сочетании с контейнерными технологиями, которые создавались именно под такие приложения.

**Каждый микросервис всегда отвечает своей бизнес-потребности и не больше.** В этом и заключается основной паттерн проектирования микросервисов, который допускает дублирование функционала микросервисов и исключает переиспользование в угоду независимости от соседних микросервисов и упрощению логики.
# Особенности микросервисной архитектуры

## Преимущества

**Гибкость**. Небольшие команды отвечают за небольшой кусок кода.

**Масштабирование**. Возможность динамично и горизонтально масштабировать отдельные участки приложения.

**Частые релизы.** Можно часто обновлять отдельные микросервисы с меньшим риском, в отличие от монолита.

**Высокая надежность.** Функциональные возможности работают отдельно друг от друга, поэтому снижается риск отказа всего приложения сразу.

## Недостатки

**Разрастание процесса разработки.** Количество микросервисов растет, вслед за ним увеличивается число людей, занятых разработкой и сопровождением.

**Неопределенность в вопросах владения.** Нередко проблема четкого разделения зон ответственности всплывает при планировании, бюджетировании, а также в случае возникновения проблем — когда что-то упало.

**Экспоненциальный рост расходов на инфраструктуру.** Если раньше монолит жил на одном сервере, то микросервису в Kubernetes может понадобиться все 10. И про базы забывать не стоит. Выше потребность в ресурсах, выше расходы на инфраструктуру.

**Отладка.** Нередко отладка из рядового процесса превращается в комплекс мероприятий по поиску бага среди 10 команд, три из которых вчера выкатили новые релизы.

**Реагирование на инциденты.** Реагирование на инциденты тоже усложняется. Например, если у клиента не работает сервис, вряд ли он будет разбираться в каком модуле произошла поломка. Тикет прилетит на сервис, и расследованием займутся все те же 10 команд.

**Интеграция между микросервисами.** Наладить взаимодействие между сервисами, состоящими из множества микросервисов, — задача не из легких. Если раньше два монолита могли успешно общаться через шину, то с налаживанием общения микросервисов и выгрузкой данных придется повозиться.

# Децентрализация данных

У микросервисной архитектуры есть еще один спорный момент, связанный с децентрализацией данных.

**Отсутствует общая база данных.** Вместо нее теперь 2 -3 БД. С одной стороны, есть свои преимущества: высокая производительность, отсутствие влияния одних данных на другие.

**При разных базах данных создается необходимость согласовывать все базы данных между собой.** Там, где раньше все решала транзакционная логика БД, теперь две независимые базы, изменения, в которых надо как-то согласовывать. Приходится изобретать велосипед — перекладывать транзакционную логику на приложение, использовать медленные распределенные транзакции или вовсе отказываться от согласованности в некоторых местах. В итоге, выигрывая в изолированности и скорости, мы проигрываем в базовом функционале, который приходится реализовывать иначе.

**Под различные цели подбирается свое хранилище.** Однако положительный момент у этого тоже есть — под каждую конкретную цель можно подобрать свое хранилище.

# Ключевые технологии для микросервисной архитектуры

Напоследок немного о ключевых технологиях для микросервисной архитектуры. К ним относятся:

●       Docker-контейнеры

●       Kubernetes

●       API-шлюзы

●       Логирование и мониторинг

●       CI/CD

●       REST+HTTP

●       Очереди сообщений

# Подведем итоги

●       Микросервисная архитектура — это способ создания программных продуктов, предполагающий разработку независимых друг от друга модулей.

●       Для этого между микросервисами используется API, которое подразумевает прием и передачу межсервисных сообщений по стандартным каналам.

●       В отличие от монолитной архитектуры архитектура микросервисов состоит из независимо работающих модулей. Каждую службу можно разрабатывать, обновлять, развертывать и масштабировать отдельно от остальных. Это позволяет чаще выполнять обновления, повышая надежность, время бесперебойной работы и производительность программного обеспечения.

●       Свойства микросервиса: компактность, разделение ответственности, независимость, простота и ясность интерфейсов. Микросервис в большей мере Stateless, чем Stateful. Каждый микросервис всегда отвечает своей бизнес-потребности и не больше.

●       К преимуществам микросервисной архитектуры относят гибкость, масштабирование, частые релизы и высокую надежность. К недостаткам — разрастание процесса разработки, неопределенность в вопросах владения, экспоненциальный рост расходов на инфраструктуру, сложность интеграции между микросервисами, трудности при отладке и реагировании на инциденты.

●       Для микросервисной архитектуры характерна децентрализация данных. Вместо единой базы появляются 2-3 БД, наличие нескольких разных баз данных вызывает необходимость согласовывать все БД между собой. Но есть и плюс — под каждую цель можно подобрать свое хранилище.

●       К ключевым технологиям микросервисной архитектуры относятся Docker-контейнеры, Kubernetes, API-шлюзы, логирование и мониторинг, CI/CD, REST+HTTP, очереди сообщений.
