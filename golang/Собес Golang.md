	# СКРИНИНГ
## О себе:

DataLab - 12:30 скрин

//С начала 2020 года ,из-за того что поступал в вуз на IT специальность, начал серьезно изучать программирование. Началось

В году 19-20 начал изучать веб, сначала тыкал фронт - react___Vue. После понял что все таки хочется больше писать код и взаимодействовать с данными напрямую, а не верстать с перфектпикселем на html. В итоге решил перейти на node js, так как js уже знал. Нашел первую работу - был стартап, суть создание сайта по изучению SQL (практика плюс теория) и тимлид писал расширение в VSCode для визуализации таблиц, связей и в целом всех SQL запросов. Проект закончился, так как такое расширение создали за пару месяцев до конца нашей работы и в первый же месяц было около миллиона скачиваний (Китаец опередил). Потом нашел друзей которые в тот момент уже работали на go, они убедили в том, что строго типизированные языки топ и гошка сейчас один из самых востребованных языков, так что я быстренько подучил основы и устроился на работу. На работе помогли знания ноды, так как мы пилили монолит с ноды на микросервисы гошку. Потом оптимизировали работу приложения, дописывали микросервисы и поддерживали продукт. Получается 15 числа много разрабов сократили, так как все доработки по сайту сделали, оставалось поддерживать сайт и бессмысленно было оставлять большое количество разработчиков.

## Чем занималась компания:

Компания занималась внедрением способов оплаты для клиентов. Когда я только пришел в компанию был монолит на ноде, мы должны были переписать на гошку. После того как переписали, лично я разрабатывал три дополнительных микросервиса:
- ЕС(entity centre);
- Шадоулер (планировщик);
- Нотификационный сервис.

## Что я делал в компании:

![[Pasted image 20240120154632.png]]

**Вкратце:**
- EC позволял приложению предоставлять другим микросервисам entity.
- Шадоулер это такой планировщик, в нем можно было создать таску на определеный итервал и на определеное время
- Нотификационный сервис который мог через кафку присылать отчеты, это я считаю своим достижением - у меня получилось добиться 5000 сообщений в секунду.

**Подробнее:**
Entity центр делал так, чтобы приложение могло предоставлять всем остальным микросервисам entity(объект), все на старте обращались к EC(entity center) и в кеше записывали все сущности которые им нужны по прото (протобаф, для общения между сервисами) и если сущность обновлялась, в EC шла нотификация в кафку и те кому надо подписывались на нужный топик (то куда попадют данные) и обновляли нужные entity.

Остальные два микросервиса по сути связаны между собой, это 
нотификационный(сервис уведомлений) сервис и шэдулер(планировшик).

Нотификационный с более сложной логикой, так как он подключался к разным мерчантам(принимает оплату) и терминалам(то через что проходит оплата), вытаскивал из ЕС настройки, отправлял по http или email, либо другими транспортам (транспортным протоколам, в основном http) во вне (во внешние зависимости чистой архитектуры)

Шедовлер это некий планировщик, в нем можно было создать таску(задачку) на определенное время с определенными интервалами, к примеру каждые 4 дня отправлять нотификацию об отчетах, он также под кафкой отправлял уведомление в EC и EC уже отправляла уведомление по нужному доступу

- EC(entity centre)
- Шадоулер
- Нотификационный сервис

## Команда:

- 2 Гошера
- 1 ТехЛид, по совместительству третий гошер
- 3 Frontend (React.js / Vue3, Tailwind, Scss, TypeScript)
- 1 Designer (Figma)
- 1 Тестировщик
![[Pasted image 20240120154258.png]]

## Стэк компании:

**Стэк:**
- PostgreSQL
- Redis (хранит данные в оперативной памяти)
- Swagger
- Kafka Apache
- Docker
- gRPC
- Golang
- Gin


pig

clickhouse
## Почему решили уйти с прошлой работы:

Проект заканчивался (мы остались в хороших отношениях).

## Сильные стороны:

Я внимателен к мелочам, выполняю все свои задачи в срок и категоричен к себе, а еще докапаюсь до истины с помощью гугла/стаковерфлоу и хабра в IT мне достаточно легко все дается.
## Слабые стороны:

Люблю поговорить про разные технологии, и про интересные факты.


## Работали не очень официально и зп получал в крипте (эфир) самозанятость
## Что важно на работе:

Важен комфорт и классная команда к которой я всегда могу обратиться и ко мне также.

## Как планируешь развиваться на проекте:

Для начала познакомлюсь с командой потом посижу пару деньков посмотрю проект, разберусь в архитектуре, изучу технологии с которыми был не знаком в течении двух дней (если такие будут, условный кубер) и приступлю к работе.

## Мои вопросы:…
## Подробнее про микросервисы

Вопросы:
- Что делает Нотификационный сервис?
	- В Нотификационный сервис приходит уведомление о том что нужно запланировать такую то нотификацию, и он должен уведомить хост, дальше может кинуть уведомления по email или телеграмм.

- Как вы отслеживали ошибку (Менеджер мониторинг падения)?
	- grafana изменяется график

- Как замеряли нагрузку?
	- grafana

- Как развертывали?
	- devops настраивали через пайплайн, если он успешен, то там был настроен дэплой

	- открывал несколько vs кодов запускал каждый сервис 

# ТЕХ ВОПРОСЫ
## Плюсы и минусы Go

Плюсы:
- Простой синтаксис
- Легкий для новичков
- Существование гарбиш коллектора
- Много встроенных инструментов для разработчиков
	- пример
		- gas найдет уязвимости
		- go vet обнаружит ошибки в коде
		- gofmt правильно отформатирует код, проставит пробелы для выравнивания и табы для отступа
- Большое количество библиотек
- Высокая производительность
- Надёжность 
	- грамотное использование памяти и вычислительных ресурсов
- Кроссплатформенность
- Поддержка UTF-8
	- Я читал и по моему в Go одна из наиболее полных среди всех ЯП

Минусы:
- Ограниченный функционал
	- Создание графического интерфейса (плохо)
- Размер
	- При компиляции маленькой программы можно получить файл в несколько Мб
- Работа с памятью
	- Не существует средства ручного управления памятью
	- Нельзя настроить поведение сборщика мусора


## ==Kafka

![[Pasted image 20240128233511.png]]
![[Pasted image 20240128233536.png]]
![[Pasted image 20240128233558.png]]
![[Pasted image 20240128233848.png]]

ТОПИКИ - это стрим данных, по сути это получение каких то однотипных событий, в топике есть очередь и туда складываются и вынимаются данные. FIFO

В ТОПИКЕ могут быть партиции, грубо говоря это создание дополнительных потоков.

Стоит распределять партиции по брокерам. (чтобы избежать highload на один брокер)

Где хранятся данные топика - в LOG файлах (есть папки под каждую партицию и в них есть лог файлы) 

Удаление TTL(time-to-live)



## Строки

Строка под капотом - это массив байт или рун, в зависимости от того что находится в строке.

Строки - имутабельны.

**Оператор len для строчки** возвращает количество байт, то есть на него не стоит опираться если у тебя какой нибудь unicode, ну в плане того что ты хочешь символы читать. Там какой то есть метод в пакете strings кажется.

**С оператором квадратные скобки** будет то же самое. 

## ==Массивы и слайсы

Массив по сути фиксированный кусок памяти, у которого мы должны указать его длину и вместимость перед компиляцией.

Слайс (динамический) является такой абстракцией над этими массивами который позволяет делать динамический размер, то есть под капотом у слайса лежит:
1) Указатель на базовый массив
2) Длина слайса
3) И ёмкость (капасити)

В случае переполнения данного выделенного куска памяти происходит перелокация данного куска памяти большего размера. Ну и это позволяет обеспечить нам динамическое содержимое.

Сложность выполнения операций у слайса:
- При обращению к одному элементу сложность будет константной;
- Когда происходит вставка в конец и у нас не переполняется слайс, то сложность тоже будет константной;
- В случае если мы вставляем в начало или в конец с переполнением, будет линейная сложность;
- При удалении из начала линейная, так как прийдется смещать все элементы;
- Удаление из конца константная сложность.


**Вставка и чтение из неинициализированного слайса (ок/не ок)**
OK

**Обращение к неинициализированному слайсу (ок/не ок)**
Не ок, скажет что ты вышел за пределы доступного.
## ==Мапы
В Go мапа это хэш таблица.

Если смотреть верхнеуровнего, то это просто неотсортированный контейнер данных ключ значение.

В качестве ключа можно указать почти все типы данных кроме:
- slices
- maps
- funcrions
- struct с incomparable (типами полей)

При вставке ключ проходит через хэш функцию, получается значение какое то хэша, тут надо оговорится о свойствах хэш функции:
1) Она устроена таким образом, то что на входе даёт всегда на выходе один и тот же результат.
2) Близкие ключи стараются делать хэши их далекими друг от друга по значению, чтобы более менее равномерно распределять по диапазону хэшей вот, но естественно могут возникать коллизии когда у нас разные ключи на входе дают один и тот же хэш.
3) Дальше в го под капотом бакеты существуют, так скажем ведра значений. В каждом бакете емкость 8 пар ключ значений, сначала идут все ключи, потом все значения.

Также есть механизм эвакуации данных, он считает среднее значение по бакетам, и если значение больше по моему 6,5, то он делает эвакуацию данных, то есть выделяет новый кусок памяти и перекидывает туда данные. 

Коллизия
Когда коллизия происходит, вот мы прилетаем в бакет и к примеру у нас там уже забился бакет, мы можем начать плодить на конкретный диапазон хэшей связный список бакетов, ну и когда идет операция чтения он залетает в бакет, начинает проверять если никого не нашел дальше смотрит есть ли еще один бакет в связном списке, если есть он там проверяет, если там не нашел, то всё сорян нет такого.

Вставка из чтение из неинициализированной мапы:
- Вставка это конечно печально, будет паника, типичная ошибка.
- Чтение ну вроде нормально.

## ==Горутины

Горутина - это легковесный поток, по сути сущность которая управляется гошным шедулером(планировщиком). В отличие от потока у горутины динамически расширяемый стэк. 

GOMAXPROCS - отвечает за количество используемых потоков.

## ==Каналы
Каналы - это инструмент коммуникации который позволяет обмениваться данными между горутинами.

Структура канала (это не всё... ТОЛЬКО ОСНОВНОЕ):
```Go
type chan struct {
	nx sync.mutex
	buffer []T
	readers []Goroutines
	writers []Goroutines
}
```


Допустим что то пишем в канал, если буф будет возможность писать в этот канал пока буфер не забъётся, происходит зависание, там по моему какая то очередь формируется. Ну и пока мы не начнем вычитывать так и будем висеть, как только начнем, начнет его отпускать. Ну и та же самая история небуф, там также будет ждать и всё. 

Ну там мьютексы под капотом естественно.

Буферизированные - записываем пока на закончится буфер.

Небуферизированные - когда мы саписываем мы лочимся и ждем пока кто то прочтет. Если никто не прочтет будет deadlock.

Если лочить два мьютекса можно напороться на deadlock, друг друга будут ждать.

У канала есть Len и Capasity

Создание канала:
- var nilChanel chan int // будет канал со значением NIL
	- Нельзя записать и прочитать данные, будет DEADLOCK
- unbufferedChanel := make(chan int) // небуферизированный
	- Обязательно должен быть и слушатель и читатель 1:1, иначе DEADLOCK
	- В закрытый канал нельзя записывать PANIC
- bufferedChanel := make(chan int, 2) // буферезированный
## ==Контектсы 

Контекст - это пульс программы который прокидывается везде, чаще всего используют для того чтобы регулировать  какой-нибудь таймаут, то есть там можно либо время задать когда он сдохнет, либо промежуток через который он помрет. Ну и соответственно когда контекст отменяется идет сигнал в канал дан и на него можно реагировать, ну например когда пачка горутин запущена, чтобы их синхронизировать когда всё сдохло.

У контекста две задачи:
- хранить значения
- сообщать о завершении

1) context.Background()
	1) кладем данные которые нам понадобяться дальше, к примеру куки, данные клиента, т.д.
	2) Background создает наш корневой контекст
2) context.TODO()
	1) сообщать о завершении 
	2) TODO нужно юзать только в тестах, на этапах разработки, не совсем важный

методы:
- WithValue // добавляет значение ключ значение
- WithCancel // получаем функцию которая может отменить наш контекст
- With Deadline // завершение через время
- With timeout // чаще юзают 

Кроме этого можно в контексты накидывать свои какие то значения и там есть для этого интерфейс, методы в интерфейса, ну типо можно докинуть туда информацию авторизационную, токен какой нибудь пришел мы его распарсили и туда положили, роли там которые тоже в токене были распарсить положить.


## ООП в Go

В Go нет классического ООП, но есть похожие возможности. Нет классов, объектов, исключений и шаблонов, но есть возможность описывать свои типы или структуры.
По сути структуры с методами служат тем же целям, что и классы в других языках.


Инкапсуляция в Go реализована на уровне пакетов. Названия начинающиеся со строчной буквы будут видны только внутри пакета, а с заглавной - доступно извне пакета.


Нет наследования, но есть структуры - типы данных, которые могут включать в себя другие типы, в том числе и такие же структуры. При встраивании реализация дочерних методов перезаписывает реализацию родительских.


Полиморфизм за счет структур и интерфейсов, а именно создания методов с одинаковым названием для разных структур.


## ==Структуры

Интер - описывают поведение какого либо объекта которое мы ожидаем 

для соответствия некому интерфейсу тип данных или структура должна реализовывать все методы данного интерфейса

объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей, наследования и принадлежности к какой-либо конкретной структуре.
## Интерфейсы

Интерфейс - это контракт

Интерфейсы - это типы, которые объявляют наборы методов. 

Также в Go присутствует duckttyping - это так скажем, если объект реализовывает все методы данного интерфейса, то он автоматически реализует интерфейс.

## ==Сборщик мусора

Гарбиш коллектор реализован с помощью алгоритма Mark and Sweep - трехцветный.

Как работает алгоритм:
- Данные в куче рассматриваются как граф связанных объектов
- Каждый объект может быть раскрашен белым серым или черным
- Изначально все белые
- После мы начинаем сканировать корневые объекты - помечаем серым
- Дальше выбираем серый объект из очереди и сканируем на наличие указателей помечаем черным
- Найденные объекты помечаются серым цветом, а исходный объект черным
- И повторяем это до тех пор, пока очередь серых объектов не станет пустой
- В итоге остаются только черные и белые объекты
- Белые объекты являются мусором, так как на них больше не ссылается ни одна переменная и их можно удалить
## ==Panic
Паника - это особая ситуация, когда программа говорит о том что произошло что-то неожиданное.


обработка паник осуществляется с помощью panic recover

С помощью panic("Ошибка парсинга") мы создаем панику

С помощью recover() мы обрабатываем ошибку
```Go
defer func() {
	panicValue := recover()
	fmt.Println(panicValue)
}
```

Если паника произошла, значение будет текст этой паники, если нет nil
## ==Пакет синк

### SINC MAP

Предоставляет атомарный доступ

Мапы в го не потокобезопасны к записи, поэтому есть синк мапы, но их стоит юзать когда важна минимальная задержка в работе приложения, только с условием что ваш сервер имеет проц с минимум 64 ядрами.

В противном случае лучше реализовать структуру в которой будет мапа и RWMutex.


### Mutex

```Go
func writeWithMutex() {
	start := time.Now()
	var counter int
	var wg sync.WaitGroup
	var mu sync.Mutex

	wg.Add(1000)
	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()
			time.Sleep(time.Nanosecond)

			mu.Lock()
			counter++
			mu.Unlock()
		}()
	}
	wg.Wait()

	fmt.Println(counter)
	fmt.Println(time.Now().Sub(start).Second())
}
```

ПРИ ВЫПОЛНЕНИИ КРИТИЧНОГО УЧАСТКА КОДА, В НАШЕМ СЛУЧАЕ ЗАПИСИ COUNTER, НУЖНО ИСПОЛЬЗОВАТЬ БЛОКИРОВКУ ЧЕРЕЗ MUTEX, ЧТОБЫ ДАННЫЕ ЗАПИСЫВАЛА КАКАЯ ТО ОДНА ГОРУТИНА, А ПОТОМ НУЖНО РАЗБЛОКИРОВАТЬ.

У MUTEX ЕСТЬ МЕТОДЫ:
	С ПОМОЩЬЮ НИХ МОЖНО НАЛАДИТЬ ПОТОКОБЕЗОПАСНОСТЬ ГОРУТИН

m.Lock() - БЛОКИРОВКА ВСЕХ ГОРУТИН, КРОМЕ ОДНОЙ

m.Unlock() - РАЗБЛОКИРОВКА ВСЕХ ГОРУТИН

### RWMutex

В случае если мы хотим сделать блокировку на чтение, быстрее (примерно в 2 раза) будет работать RWMutex, у него есть следующие методы:

RLock() - блокирует горутины на чтение

RUnLock() - разблокирует горутины на чтение

Использование RWMutex может увеличить параллелизм в программе, так как позволяет много потоков читать данные без блокировки, в то время как обычный Mutex предотвращает любой доступ, кроме одного потока, во время записи или чтения.
### WaitGroup - инструмент синхронизации

```Go
func withWait() {
	var wg sync.WaitGroup

	//wg.Add(10) - одно и то же получится
	for i := 0; i < 10; i++ {
		wg.Add(1)

		go func() {
			// defer wg.Done()
			fmt.Println(i + 1)
			wg.Done()
		}(i)
	}

	wg.Wait()
	fmt.Println("Exit")
}
```


WaitGroup - это средство в Go для синхронизации горутин (goroutine). WaitGroup используется для дожидания завершения выполнения набора горутин перед продолжением работы основного потока.


wg.Add() - добавление задачи на ожидание
	ДОБАВЛЯТЬ ЗАДАЧУ НУЖНО ПЕРЕД ГОРУТИНОЙ, А НЕ ИЗНУТРИ

wg.Done() - говорим о том что мы выполнили эту задачу
	КАК ТОЛЬКО ВЫПОЛНИМ ОТЧИТЫВАЕМСЯ ЧТО ЗАВЕРШИЛИ

wg.Wait() - переходит из запущенного состояния в заблокированное, то есть она находится в состояние ожидания
	ДОЖИДАЕМСЯ ВЫПОЛНЕНИЯ ВСЕХ ЗАДАЧ



## ==DataRace

DataRace - это обращение к одним и тем же данным из разных горутин, где одно из обращений - запись.
## ==SQL