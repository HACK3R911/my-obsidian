# Скрининг

Программирую с 20 года, изначально был на фронте, разные подработки на фриланс биржах, потом перешел на бэк node поучаствовал в стартапе, потом перешел на golang пилили монолин с ноды. Дальше писал пару проектов, один был полностью под NDA для МТС, про другой могу рассказать, это было приложение с апишкой для умной бутылки, которая трекает выпитую воду и данные здоровья..

Микро-сервисы которые я разрабатывал:
- Auth 
- drink control
- health control 

# Тех вопросы
## ==Golang==
### Типы данных

- bool:
	- true
	- false
- string:
	- строка - это иммутабельные массивы байтов "A" == [1]byte{65}
	- иммутабельность - это объект, которые после инициализации, не может быть изменён.
- int:
	- int8
		- от -(2^7) до 2^7-1
		- занимает место в памяти =  1 байт
	- int16
		- от -(2^15) до 2^15-1
		- занимает место в памяти =  2 байт
	- int32
		- от -(2^31) до 2^31-1
		- занимает место в памяти =  4 байта
	- int64
		- от -(2^63) до 2^63-1
		- занимает место в памяти =  8 байт
	- - int
		- от -(2^63) до 2^63-1 || от -(2^31) до 2^31-1 (Зависит от платформы)
		- занимает место в памяти = 8 байт
- uint:
	- uint8
		- от 0 до 2^8
		- занимает место в памяти = 1 байт
	- uint16
		- от 0 до 2^16
		- занимает место в памяти = 2 байт
	- uint32
		- от 0 до 2^32
		- занимает место в памяти = 4 байта
	- uint64
		- от 0 до 2^64
		- занимает место в памяти = 8 байт
	- - uint
		- от 0 до 2^64 || от 0 до 2^32 (Зависит от платформы)
		- занимает место в памяти = 8 байт
- byte:
	- byte == uint8
		- от 0 до 2^8
		- занимает место в памяти = 1 байт
		- Этот тип показывает закодированные данные в байтах(числовом формате), если байты перевести в строку, мы получим набор символов в соответствии с таблицей ASCII
		- Пример:
			- str := "AB"
			- bytes := []byte(str)
			- fmt.Println(bytes ,"=", string(bytes))
			- // Выведет: [65 66] = AB
- rune:
	- rune == int32
		- от -(2^31) до 2^31-1
		- занимает место в памяти = 4 байта
		- rune - это символ кодировки UTF8
		- rune - это то же самое что и byte, только более расширенная версия, например в неё входят смайлики.
- float:
	- float - это числа с плавающей точкой
	- чаще всего используются как результат от деления
	- разная разрядность
		- float32:
			- от -(2^31) до 2^31-1
			- занимает место в памяти 4 байта
		- float64:
			- от -(2^63) до 2^63-1
			- занимает место в памяти 8 байт
- complex(Очень редко используют):
	- complex нужен для работы с комплексными числами
	- complex64
		- от -(2^63) до 2^63-1
	- complex128
		- от -(2^127) до 2^127-1

### ООП

В Go нет классического ООП, но есть похожие возможности. Нет классов, объектов, исключений и шаблонов, но есть возможность описывать свои типы или структуры.
По сути структуры с методами служат тем же целям, что и классы в других языках.

Инкапсуляция в Go реализована на уровне пакетов. Названия начинающиеся со строчной буквы будут видны только внутри пакета, а с заглавной - доступно извне пакета.

Нет наследования, но есть структуры - типы данных, которые могут включать в себя другие типы, в том числе и такие же структуры. При встраивании реализация дочерних методов перезаписывает реализацию родительских.

Полиморфизм за счет структур и интерфейсов, а именно создания методов с одинаковым названием для разных структур.

### Строки

Строки - массив байт, так как это массив, мы не можем его менять, поэтому строки имутабельны. К строке можно применить len().

byte может храниться любой символ ASCII

rune = int32 используется для представления одного кодового пункта Unicode

### Массив/Слайс

Массив - это динамически не изменяемая структура данных которая содержит в себе коллекцию каких то определенных типов.

Слайс - это динамически расширяемая структура данных, также как и массив содержит коллекцию однотипных данных. При переполнение слайса его ёмкость увеличивается в коэфиценте, до 256 вроде 1.8, до 512 1.6, до 1024 1.4, и т.д.

```go
struct {	
	array *[]T
	length int	
	capacity int
}
```

Отличия:
- Слайс имеет структуру, массив нет (длина, ёмкость и ссылка на базовый массив)
- Динамичность (слайс расширяется массив нет)

### Мапа

![](Pasted%20image%2020250305104156.png)

Верхнеуровнево это просто неотсортированный контейнер данных ключ значение.

В качестве ключа можно указать почти все типы данных кроме:
- slices
- maps
- funcrions
в общем в ключ могут пойти только comparable типы

При вставке ключ проходит через хэш функцию, получается значение какое то хэша, свойства хэш функции:
1) Она устроена таким образом, то что всегда на входе и на выходе один и тот же результат.
2) Близкие ключи стараются делать хэши их далекими друг от друга по значению, чтобы более менее равномерно распределять по диапазону хэшей вот, но естественно могут возникать коллизии когда у нас разные ключи на входе дают один и тот же хэш.
3) Дальше в го под капотом бакеты существуют, так скажем ведра значений. В каждом бакете емкость 8 пар ключ значений, сначала идут все ключи, потом все значения.

Также есть механизм эвакуации данных, он считает среднее значение по бакетам, и если значение больше по моему 6,5, то он делает эвакуацию данных, то есть выделяет новый кусок памяти и перекидывает туда данные.

Вставка из чтение из неинициализированной мапы:
- Вставка это конечно печально, будет паника, типичная ошибка.
- Чтение ну вроде нормально.

### Каналы

Канал - это способ коммуникации между горутинами (обмениваться данными).

В основном структура канала состоит из мьютекса, буфера, читающих и пишущих горутин:
```Go
type chan struct {
	mx sync.mutex
	buffer []T
	readers []Goroutines
	writers []Goroutines
}
```

Каналы бывают двух типов:
- Буферизированные - можно писать пока не закончиться буфер.
- Небуферизированный - когда мы записали, лочимся и ждем пока кто-то прочитает. Если никто не прочтет будет deadlock.

Создание канала:
- var nilChanel chan int // будет канал со значением NIL
	- Нельзя записать и прочитать данные, будет DEADLOCK
- unbufferedChanel := make(chan int) // небуферизированный
	- Обязательно должен быть и слушатель и читатель 1:1, иначе DEADLOCK
	- В закрытый канал нельзя записывать PANIC
- bufferedChanel := make(chan int, 2) // буферезированный

### Интерфейс и структуры

Интерфейс - это набор методов для которых не указаны конкретные реализации.

Если определенный тип предоставляет методы, соответствующие всем методам интерфейса, считается, что этот тип реализует данный интерфейс (утиная типизация). В Go не нужно явно указывать, что тип реализует интерфейс 0 это определяется неявно.

Структуры представляют тип данных, определяемый разработчиком и служащий для представления каких-либо объектов. Структуры содержат набор полей, которые представляют различные атрибуты объекта.

### Мьютексы

Мьютексы - в переводе взаимное исключение, обеспечивает безопасный доступ к общим ресурсам. Мьютексы - это один из наиболее распространенных примитивов синхронизации.

Вызываем Lock(), по завершению изменения/чтения данных Unlock().

sync.Mutex - это мьютекс для эксклюзивных блокировок. Только одна горутина может захватывать мьютекс и получить доступ к общему ресурсу.

### WaitGroup

WaitGroup является структурой из пакета sync, для того чтобы дождаться выполнения всех горутин которые мы добавили.

Add() - добавляет количество потоков к существующему значению счетчика.

Done() - уменьшает значение счетчика на единицу.

Wait() - блокирует выполнение потока, пока значение счетчика не станет равно нулю.
 
### Контексты

Context - это специальный пакет, предназначенный для передачи параметров между API и управления жизненным циклом горутин.

Основное назначение - это передача метаданных, установка временных рамок выполнения и отслеживания отмены долгосрочных операций.

Основные моменты которые мне знакомы:
- context введен в Go 1.7 и с тех пор является предпочтительным механизмом для управления временем выполнения и отменами.
- Интерфейс context.Context является основным типом, который передается между функциями.
- Основные методы:
	- WithCancel - возвращает копию переданного контекста и cancelFunc. Вызов cancelFunc отменяет этот контекст.
	- WithDeadline, WithTimeout - позволяют задать временные рамки контексту.
	- WithValue - с помощью него можно передать пары ключ/значение в context
- Отмена родительского context автоматически отменяет все дочерние
- Context используется для уведомления о том, что пора завершать работу - это особенно удобно через канал ctx.Done().
- Возвращаемая функция cancel позволяет рано завершить context.
- Не нужно хранить в context чувствительные данные (потому что контекст может быть выведен и сохранен в логах, что может раскрыть эти данные)
- ==context.Background() и context.TODO()== - одно и то же. Разница в том, что TODO выставляется в местах, где пока нет понимания что необходимо использовать Background и возможно его надо заменить на дочерний context
- Когда context отменяется (через cancel, timeout или deadline), ctx.Done() возвращает закрытый канал. Это удобный механизм для того чтобы сказать горутине что пора завершать работу.

### Горутины

Горутина - это легковесный поток, по сути сущность которой управляет гошный планировщик. В отличие от потока у горутины динамически расширяемый стэк. 

GOMAXPROCS - отвечает за количество используемых потоков.

### Runtime

Нужен для управления горутинами, существенно упрощает работу с go, например в C подобных языках нужно вручную настраивать сборщик мусора, а в go за runtime делает это автоматически.

### defer

функция которая вызывается после выполнения метода/функции, если их несколько вызываются в порядке стека.

### Планировщик---Сборщик мусора

Планировщик(scheduler) в Go отвечает за распределение задач по горутинам на основе доступных ресурсов процессора. Он обеспечивает параллельное выполнение кода, управляет планированием горутин и учитывает доступные процессорные ядра.

Сборщик мусора нужен для автоматического управления памятью, он отслеживает и удаляет неиспользуемые объекты из памяти для освобождения ресурсов. Использует алгоритмы Mark-and-Sweep(Метка и удаляй), Stop-the-World(Останови мир), Конкурентный Mark-and-Sweep, и Трехцветный алгоритм.

- подробнее про алгоритмы:
	- - Mark-and-Sweep: Этот алгоритм заключается в том, что сборщик мусора помечает все объекты, которые доступны для программы, а затем удаляет объекты, которые не были помечены. Это простой и эффективный метод, но может вызывать задержки в работе программы.
	- Stop-the-World: Этот алгоритм останавливает выполнение программы, чтобы провести сборку мусора. Это может привести к замедлению работы программы на некоторое время, пока происходит сборка мусора.
	- Concurrent Mark and Sweep: Этот алгоритм позволяет проводить сборку мусора параллельно с выполнением программы, минимизируя задержки и улучшая производительность.
	- Tri-color Mark and Sweep: Этот алгоритм использует три цвета для пометки объектов: белый (недоступный), серый (доступный, но еще не просмотренный) и черный (доступный и просмотренный). Он позволяет проводить сборку мусора эффективно и без остановки программы.

## ==gRPC/HTTP==
### gRPC

gRPC - это современная технология удаленного вызова, которая позволяет создавать эффективные, отказоустойчивые и масштабируемые микросервисы.

Плюсы:
- Высокая производительность за счет того, что он основан на структуре protocol buffers.
- Поддержка разных языков
- Генерация кода protoBuf
- Поддержка асинхронных вызовов (двусторонний поток)

Минусы:
- Сложность настройки SSL, аутентификации и мониторинга
- Сложность отладки (из за сжатия данных и бинарных протоколов)

Например, можно создать простое клиент-серверное приложение, которое будет использовать gRPC для обмена сообщениями между собой.

### HTTP

HTTP (HyperTextTransportProtocol) - протокол передачи гипертекста, 

- Http/1.1
	- Первая версия, опубликован по моему в 1997 году.
	- Основан на принципе запрос-ответ, клиент отправляет запрос, сервер отвечает на него
	- Недостатки есть, например блокировка главного потока и множественные запросы к одному серверу, что замедляет загрузку страницы, особенно для больших сайтов.
- Http/2
	- Выпущен в 2015 году, по сути глобальное обновление http/1.1
	- Поддерживает безопасное соединение по умолчанию, используя протокол TLS.
	- заголовки передаются в бинарном формате
	- поддерживает многопоточность (можно одновременно обрабатывать несколько запросов и откликов)
- Http/3
	- Крайняя версия, опубликован в 2020 году
	- Использует протокол QUIC (Quick UDP Internet Connections) вместо TCP, чтобы увеличить скорость передачи информации.
	- включает в себя механизмы коррекции ошибок и управления потоками для надежности и производительности передачи данных.

### Отличия

1) http - текстовый протокол, gRPC использует бинарный протокол
2) http поддерживает JSON, XML и другие текстовые форматы, gRPC использует ProtocolBuffers для сериализации данных
3) http работает на основе запрос-ответ, gRPC поддерживает синхронные и асинхронные вызовы
4) http поддерживает только запросы GET, POST, PUT, DELETE и еще несколько, а gRPC использует полноценные RPC для вызова удаленных функций
5) gRPC более производителен из-за бинарных протоколов и многопоточности
6) http более распространен и легко интегрируется с различными системами

## ==Чистая архитектура==

Основная идея - архитектура ПО должна быть гибкой, четко структурированной и легко поддерживаемой.

Принципы:
- Стабильные абстракции
	- код должен быть организован так, чтобы изменения в одной части программы не приводили к неожиданным изменениям в других частях.
- Однозначное разграничение ответственностей
	- разные компоненты программы должны иметь четко определенные обязанности
- Независимость от деталей реализации
	- Компоненты программы должны быть высоко уровнемыми, чтобы изменения в деталях реализации не затрагивали всю программу
- Продуманная структура зависимостей
	- компоненты программы должны зависеть от абстракций, а не от конкретных реализаций
- Тестирование
	- Чистая архитектура поощряет написание автотестов для всех компонентов программы

Основные компоненты:
- Entities (Сущности)
	- базовые структуры данных приложения
- UseCases
	- определяют бизнес-логику и действия,которые система должна выполнять 
- Interfaces
	- Определяют контракты для взаимодействия между разными компонентами системы
- Repositories
	- Отвечают за доступ к данным
- Frameworks
	- Фреймворки и библиотеки, которые используются для реализации конкретных функций (например веб-серверы, бд)
- Main
	- Точка входа в программу

## ==Структуры==
### Односвязный список

Односвязный список - это совокупность элементов в которой каждый элемент знает адрес следующего элемента.

О. список - это динамическая структура данных, у которой есть две основные характеристики:
- это быстрая операция при добавлении и удалении элементов списка.
- и медленная операция поиска элементов в списке.

### Двусвязный список

Двусвязный список - это то же самое что и односвязный список, только:
- он работает быстро в конце тоже
- в серидине работает медленно
- есть указатель на предыдущий элемент

| Pointer Next | 1 | 2 | 3 | 4 | nill |
| ---- | ---- | ---- | ---- | ---- | ---- |
| Pointer Prev | nill | 0 | 1 | 2 | 3 |
| Data | "Hello" | ", " | "my name " | "is " | "Ivan" |
| Position | 0 | 1 | 2 | 3 | 4 |

### Бинарное дерево

Бинарное дерево - это упорядоченная динамическая структура данных, которая состоит из узлов, каждый из которых имеет не более двух дочерних узлов. (левый узел обычно меньше родительского, а правый больше)

Элемент Бинарного дерева:

| Data         |               |
| ------------ | ------------- |
| Left pointer | Right pointer |

Элемент Бинарного дерева состоит из:
- Data - данные 
- Left pointer - указатель на следующий левый элемент
- Right pointer - указатель на следующий правый элемент

### Стек

Стек - это динамическая структура данных, основанная на логике односвязного списка, которая подчиняется принципу LIFO.

Запомни правило:
- LAST-IN-FIRST-OUT (LIFO).
- Последний вошел - первый вышел.

Что можно делать:
- Добавлять в начало
- Удалять начало

### Куча

Куча - это специальная структура данных, которая представляет собой древовидную структуру, каждый узел имеет значение и при этом значение каждого узла больше или равно значению его потомков(для максимальной кучи) или меньше или равно значению потомков (для минимальной кучи)

Операции:
- добавление элементов
- удаление 
- поиск минимального эл-та
- поиск максимального эл-та

### Очередь

Очередь - это модифицированный и ограниченный по функционалу двусвязный список.

Запомни правило:
- FIRST INPUT - FIRST OUTPUT
- Кто первый встал - первый выходит

Что можно делать с очередью:
- Смотреть - начале/конце очереди
- Добавить - в конец очереди
- Удалить - начало очереди

## ==Алгоритмы-- --Сложность==

Алгоритмы:
- Сортировка пузырьком
	- Последовательно сравнивать соседние элементы и менять их местами, если они стоят неправильно.
- Сортировка слиянием
	- Рекурсивно, разделяем массив пополам и сортируем каждую половину отдельно, а затем объединяем из в отсортированный массив.
- Быстрая сортировка
	- Рекурсивно, выбираем опорный элемент, который делит массив на две части (например больше меньше этого элемента), затем сортируем каждую часть отдельно.
- Бинарный поиск
	- берем отсортированный массив, сравниваем значения среднего элемента массива с искомым и двигаемся дальше к нужной половине массива.
- Поиск в ширину
	- Алгоритм поиска в графе или дереве, по сути исследуем все узлы на одном уровне перед переходом к узлам следующего уровня.
- Поиск в глубину
	- Алгоритм поиска в графе или дереве, идет вглубь от стартовой вершины, пока не найдет целевую вершину, либо не достигнет конца маршрута, после возвращается к последней вершине с доступным соседом и идет дальше.

Сложности:
- O(1) - Константная сложность
	- доступ к элементу массива по индексу
- O(log n) - Логарифмическая сложность
	- Бинарный поиск
- O(n) - Линейная сложность
	- Поиск элемента в массиве через цикл
- O(n log n) - Линейно-логарифмическая сложность
	- Быстрая сортировка
- O(n^2) - Квадратичная сложность
	- Сортировка выбором
- O(2^n) - Экспоненциальная сложность
	- Задача про коммивояжера с помощью полного перебора

## ==Методологии==
### DRY

- Don`t
- Repeat
- Yourself

Не повторяйся, вместо написание одного и того же кода, создай функцию и переиспользуй её.

### KISS

- Keep
- Is
- Simple
- Stupid

Будь проще, код должен быть проще и понятнее.

### SOLID

- S - Single Responsibility - Принцип Единой ответственности
	- Каждый класс должен иметь только одну ответственность.
		- Класс должен измениться только по одной причине. Если у класса несколько обязанностей, изменения в одной из них могут повлиять на другую.
- O - Open/Closed - Принцип открытости/закрытости
	- Программные сущности - классы, модули, функции и другие - должны быть открыты для расширения, но закрыты для изменения.
		- Код должен позволять добавлять новый функционал без изменения существующего кода.
- L - Liskov Substriction - Принцип подстановки Барбары Лисков
	- Объекты базового класса могут быть заменены объектами производного класса без изменения ожидаемого поведения программы.
		- Все методы класса-потомка должны соответствовать сигнатуре методов базового класса.
- I - Interface Segregation - Принцип разделения интерфейсов
	- Нужно разделять большие интерфейсы на маленькие специализированные, чтобы клиенты могли имплементировать только те методы, которые им нужны.
- D - Dependency Invertion - Принцип инверсии зависимостей
	- Модули верхних уровней не должны зависеть от модулей нижних уровней.
		- Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, но детали должны зависеть от абстракций.

## ==Kafka==

## ==SQL==
### ORDER BY

ORDER BY - это SQL оператор, который используется для сортировки результирующего набора данных по одному или нескольким столбцам.

### JOIN

Join используется для объединения данных из двух или более таблиц на основе какого то условия.

Есть несколько видов join:
- INNER JOIN
	- Выбирает только те строки, которые имеют соответствие в обеих таблицах по указанному условию
- LEFT JOIN
	- Возвращает все строки из левой таблице и соответствующие записи из правой таблицы. Если в правой таблице нет соответствующих записей, то будет NULL
- RIGHT JOIN
	- Возвращает все строки из правой таблицы и соответствующие записи из левой таблицы. Если в левой таблице нет соответствующих записей, то будет NULL
- FULL JOIN
	- Возвращает все строки, которые имеют соответствие в обеих таблицах, а также те, которые не имеют соответствующего в другой таблице


- INNER JOIN - возвращает только те строки, которые имеют соответствующие значения в обоих таблицах, которые объединяются
	- Используется чтобы вернуть только те строки, которые имеют совпадения в обеих таблицах
- OUTER JOIN - возвращает все строки из обеих таблиц, даже если нет соответствующих значений в другой таблице.
	- Используется для того чтобы вернуть все строки из одной или обеих таблиц, включая строки для которых нет совпадений

### Index

Индексы - это структура данных, созданная для ускорения выполнения запросов к БД. Позволяют эффективно находить и извлекать информацию из таблиц уменьшая время выполнения запроса.

Типы индексов:
- Уникальный индекс
	- каждое значение индексируемого столбца должно быть уникальным
- Составной индекс
	- создается на основе нескольких столбцов
- Кластеризованный индекс
	- данные в структуре таблицы упорядочены по значению индексируемого столбца
- Не кластеризованный индекс
	- индекс хранит ссылки на соответствующие строки в основной таблице


Плюсы:
- Ускорение выполнения запросов за счет быстрого поиска
- Улучшение производительности БД при выполнении выборок, сортировок и объединений
- Повышение эффективности работы БД при большом объеме данных

Минусы:
- Овериндексация может привести к увеличению объема БД
- Индексы требуют дополнительных ресурсов для поддержания и обновления
- При изменении данных в таблице индексы должны быть обновлены, что может снизить производительность

### Уровни изоляции

Есть 4 основных уровня изоляции транзакций, которые определяют, как одна транзакция видит изменения, внесенные другими транзакциями

- READ UNCOMMITTED (Незафиксированные чтения):
	- Это когда транзакция видит изменения, внесенные другими транзакциями, даже если они еще не зафиксированы. (То есть, данные могут быть прочитаны до завершения изменений)
	- Могут возникнуть проблемы с неповторяемым чтением и фантомным чтением
- READ COMMITTED (Зафиксированные чтения):
	- В этом уровне транзакция видит только изменения, которые были зафиксированы другими транзакциями.
	- Это предотвращает неповторяющиеся чтения, но не фантомные чтения.
- REPEATABLE READ (Повторяемые чтения):
	- В этом уровне транзакция видит только те данные, которые были прочитаны в начале транзакции, и эти данные не изменятся во время выполнения транзакции.
	- Это предотвращает неповторяющиеся чтения и фантомные чтения, но может привести к проблемам с потерянными обновлениями.
- SERIALIZABLE (Сериализуемость):
	- Этот уровень представляет собой наивысший уровень изоляции. Транзакции выполняются таким образом, чтобы результат был как если бы они выполнялись последовательно, одна за другой
	- Это предотвращает все виды фантомных чтений, неповторяющихся чтений и потерянных обновлений.

### ACID

ACID - четыре свойства, обеспечивающие надежность и целостность транзакций в реляционных БД.

- A - Атомарность
	- транзакция должна быть выполнена целиком или не выполнена вообще. Если хотя бы одно действие транзакции не удастся выполнить, то все изменения должны быть отменены.
- C - Согласованность
	- БД должна оставаться в согласованном состоянии до и после выполнения транзакции.
- I - Изолированность
	- Транзакции должны выполняться независимо друг от друга, не оказывая взаимного влияния. Данные, получаемые при одновременном выполнении нескольких транзакций, должны быть консистентными (согласованные).
- D - Долговечность
	- Изменения, внесенные транзакцией в БД, должны быть сохранены навсегда даже в случае сбоя системы или перезагрузки.
