### Методы

Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением, что в определении метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому прикрепляется метод:

```go
func (имя_параметра тип_получателя) имя_метода (пар-ры) (типы_возвращаемых_рез-ов){
	тело_метода
}
```
Допустим, у нас будет определен именованный тип, представляющий срез из строк:

```go
type library []string
```

Для вывода всех элементов из среза мы можем определить следующий метод:
```go
func (l library) print(){
    for _, val := range l{
        fmt.Println(val)
    }
}
```
Та часть, которая расположена между ключевым словом `func` и именем метода и представляет определение получателя, для которого будет определен этот метод:
`(l library)`. Используя параметр получателя (в данном случае `l`), мы можем обращаться к получателю. Например, в нашем случае получатель представляет срез - набор объектов. С помощью цикла `for` можно пройтись по этому срезу и вывести все его элементы на консоль.

Поскольку `print` представляет именно метод, который определен для типа` library`, а не обычную функцию, то мы можем вызвать этот метод у любого объекта типа `library`:
```go
var lib library = library{ "Book1", "Book2", "Book3" }
lib.print()
```
`lib` является объектом типа `library`, поэтому для него мы можем вызвать метод `print`. В данном случае объект `lib` - это и будет то значение, которое будет передаваться в функцию `print` через параметр `(l library)`.
### Методы структур

Подобным образом мы можем определять методы и для структур:

```go
package main
 
import "fmt"
 
type person struct{
    name string
    age int
}
func (p person) print(){
    fmt.Println("Имя:", p.name)
    fmt.Println("Возраст:", p.age)
}
 
func (p person) eat(meal string){
    fmt.Println(p.name, "ест", meal)
}
 
func main() {
     
    var tom = person { name: "Tom", age: 24 }
    tom.print()
    tom.eat("борщ с капустой, но не красный")
}
```
Консольный вывод данной программы:
```go
Имя: Tom
Возраст: 24
Tom ест борщ с капустой, но не красный
```
В данном случае для структуры `person` определены две функции: `print` и `eat`. Функция `print` выводит информацию о текущем объекте `person`. А функция `eat` имитирует употребление пищи. Каждая из этих функций определяет объект и тип структуры, к которой функция относится:
```go
func (p person) имя_функции
```
С помощью объекта `p` мы можем обращаться к свойствам структуры `person`. В остальном это обычные функции, которые могут принимать параметры и возвращать результат.

Для обращения к функциям структуры указывается переменная структуры и через точку идет вызов функции.
```go
tom.print()
tom.eat("борщ")
```
В данном случае `tom` - это и будет объект `p person` в определении функции.