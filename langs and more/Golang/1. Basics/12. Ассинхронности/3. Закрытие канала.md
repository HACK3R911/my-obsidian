### Закрытие канала

После инициализации канал готов передавать данные. Он находится в открытом состоянии, и мы можем с ним взаимодействовать, пока не будет закрыт с помощью встроенной функции `close()`:
```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int, 3) 
    intCh <- 10
    intCh <- 3
    close(intCh)
    // intCh <- 24       // ошибка - канал уже закрыт
    fmt.Println(<-intCh)     // 10
    fmt.Println(<-intCh)     // 3
    fmt.Println(<-intCh)     // 0
}
```
После закрытия канала мы не сможем послать в него новые данные. Если мы попробуем это сделать, то получим ошибку. Однако мы можем получить ранее добавленные данные. Но при попытке получить данные из канала, которых нет, мы получим значение по умолчанию. Например, в примере выше в канал добавляются два значения. При попытке получить третье значение, которого нет в канале, мы получим значение по умолчанию - число 0.

Чтобы не столкнуться с проблемой, когда канал уже закрыт, мы можем проверять состояние канала. В частности, из канала мы можем получить два значения:
```go
val, opened:= <-intCh
```
Первое значение - `val` - это собственно данные из канала, а `opened` представляет логическое значение, которое равно `true`, если канал открыт и мы можем успешно считать из него данные. Например, мы можем проверять с помощью условной конструкции состояние канала:
```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int, 3) 
    intCh <- 10
    intCh <- 3
    close(intCh)    // канал закрыт
     
    for i := 0; i < cap(intCh); i++ { 
         if val, opened := <-intCh; opened { 
            fmt.Println(val) 
         } else { 
            fmt.Println("Channel closed!") 
         } 
   }
}
```
Консольный вывод программы:
```
10
3
Channel closed!
```