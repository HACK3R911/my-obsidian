### Указатели как параметры функции

По умолчанию все параметры передаются в функцию по значению. Например:
```go
package main

import "fmt"
 
func changeValue(x int){
    x = x * x
}
func main() {
     
    d := 5
    fmt.Println("d before:", d)     // 5
    changeValue(d)                  // изменяем значение
    fmt.Println("d after:", d)      // 5 - значение не изменилось
}
```
Функция `changeValue` изменяет значение параметра, возводя его в квадрат. Но после вызова этой функции мы видим, что значение переменной `d`, которая передается в `changeValue`, не изменилось. Ведь функция получает копию данной переменной и работает с ней независимо от оригинальной переменной `d`. Поэтому `d` никак не изменяется.

Однако что, если нам все таки надо менять значение передаваемой переменной? И в этом случае мы можем использовать указатели:
```go
package main
 
import "fmt"
 
func changeValue(x *int){
    *x = (*x) * (*x)
}
func main() {
     
    d := 5
    fmt.Println("d before:", d)     // 5
    changeValue(&d)                 // изменяем значение
    fmt.Println("d after:", d)      // 25 - значение изменилось!
}
```
Теперь функция `changeValue` принимает в качестве параметра указатель на объект типа int. При вызове функции `changeValue` в нее передается адрес переменной `d`(`changeValue(&d)`). И после ее выполнения мы видим, что значение переменной `d` изменилось.
### Указатель как результат функции

Функция может возвращать указатель:
```go
package main
import "fmt"
 
func createPointer(x int) *int{
    p := new(int)
    *p = x
    return p
}
 
func main() {
     
    p1 := createPointer(7)
    fmt.Println("p1:", *p1)     // p1: 7
    p2 := createPointer(10)
    fmt.Println("p2:", *p2)     // p2: 10
    p3 := createPointer(28)
    fmt.Println("p3:", *p3)     // p3: 28
}
```
В данном случае функция createPointer возвращает указатель на объект int.