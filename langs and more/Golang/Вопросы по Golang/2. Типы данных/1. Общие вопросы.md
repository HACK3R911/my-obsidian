# Общие вопросы

## Что такое type switch?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-type-switch "Прямая ссылка на Что такое type switch?")

> **`Type switch`** в Go - это способ проверить, какого типа является значение, хранящееся в интерфейсе. Это похоже на обычный **`switch`**, но вместо значений в кейсах указываются типы.

```go
package main

import "fmt"

func do(i interface{}) {    
	switch v := i.(type) {    
	case int:        
		fmt.Printf("Twice %v is %v\n", v, v*2)    
	case string:        
		fmt.Printf("%q is %v bytes long\n", v, len(v))    
	default:        
		fmt.Printf("I don't know about type %T!\n", v)    
	}
}
func main() {    
	do(21)    
	do("hello")    
	do(true)
}
```

## Какие типы данных есть в Golang?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B5%D1%81%D1%82%D1%8C-%D0%B2-golang "Прямая ссылка на Какие типы данных есть в Golang?")

1. **Целочисленные типы**: **`int8`**, **`int16`**, **`int32`**, **`int64`**, **`uint8`**, **`uint16`**, **`uint32`**, **`uint64`**, **`byte`** (синоним для **`uint8`**), **`rune`** (синоним для **`int32`**), **`int`** и **`uint`.**
2. **Числа с плавающей точкой**: **`float32`** и **`float64`.**
3. **Строки**: **`string`**.
4. **Булев тип**: **`bool`**.
5. **Составные типы**: Массивы, срезы, структуры, ассоциативные массивы

## Какой длины руна?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D0%B4%D0%BB%D0%B8%D0%BD%D1%8B-%D1%80%D1%83%D0%BD%D0%B0 "Прямая ссылка на Какой длины руна?")

**`rune`** - это алиас для **`int32`**. Это означает, что **`rune`** занимает 4 байта или 32 бита. Каждая **`rune`** представляет собой один Юникод символ. Например, строка может быть преобразована в срез **`rune`** (**`[]rune`**), и каждый элемент этого среза будет представлять собой один Юникод символ.

## Как реализовать Enum в Golang?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-enum-%D0%B2-golang "Прямая ссылка на Как реализовать Enum в Golang?")

В Go нет встроенной поддержки перечислений (enum), но их можно эмулировать с помощью констант. Вот пример реализации enum в Go:
```go
package main

import "fmt"

type Season int

const (    
	Summer Season = iota    
	Autumn    
	Winter    
	Spring
)

func (s Season) String() string {    
	return [...]string{"Лето", "Осень", "Зима", "Весна"}[s]
}
func main() {    
	s := Winter    
	fmt.Println(s)
}
```

## Что если во время компиляции переполним тип? В int8 запишем 256?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D1%87%D1%82%D0%BE-%D0%B5%D1%81%D0%BB%D0%B8-%D0%B2%D0%BE-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D0%BC-%D1%82%D0%B8%D0%BF-%D0%B2-int8-%D0%B7%D0%B0%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-256 "Прямая ссылка на Что если во время компиляции переполним тип? В int8 запишем 256?")

Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.

Например, **`int8`** может хранить значения от -128 до 127. Если вы попытаетесь записать 256 в переменную типа **`int8`**, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для **`int8`**), то есть 01.

Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа

## Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?[​](https://golangreview.ru/docs/knowledge/golang/%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/overall#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%87%D0%B8%D1%81%D0%BB%D0%B0-%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B2-uint8-%D0%B2%D1%8B%D0%B9%D0%B4%D0%B5%D0%BC-%D0%B7%D0%B0-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%83-%D0%BD%D0%B0-1 "Прямая ссылка на Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?")

Если вы попытаетесь записать значение, превышающее максимально допустимое для данного типа, в Go, то произойдет переполнение типа.

Например, **`uint8`** может хранить значения от 0 до 255. Если вы попытаетесь записать 256 в переменную типа **`uint8`**, то произойдет переполнение. В результате, вместо 256 будет записано значение, которое соответствует остатку от деления 256 на 256 (количество возможных значений для **`uint8`**), то есть 0.

Важно отметить, что такое поведение может привести к неожиданным результатам, поэтому всегда следует убедиться, что значения, которые вы записываете в переменные, не превышают максимально допустимые для их типа.
