# Гонка данных

## Что такое race condition?[​](https://golangreview.ru/docs/knowledge/golang/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/race-condition#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-race-condition "Прямая ссылка на Что такое race condition?")

Состояние гонки (англ. race condition), также известное как конкуренция, - это ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Это может произойти, когда две или более операций должны выполняться в последовательности, но из-за неконтролируемых событий они выполняются в непредсказуемом порядке. В результате система или приложение может вести себя непредсказуемо или даже вызывать сбои.

Состояние гонки - это “плавающая” ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и “пропадающая” при попытке её локализовать. Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной.

Основными последствиями могут быть: утечки памяти, ошибки сегментирования, порча данных, уязвимости, взаимные блокировки, утечки других ресурсов, например файловых дескрипторов.

Источники:

- [Habr](https://habr.com/ru/articles/764234/)

## Как обнаружить race condition?[​](https://golangreview.ru/docs/knowledge/golang/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/race-condition#%D0%BA%D0%B0%D0%BA-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B8%D1%82%D1%8C-race-condition "Прямая ссылка на Как обнаружить race condition?")

В Go есть встроенный инструмент для обнаружения состояний гонки, который можно использовать при запуске или сборке вашего приложения. Вы можете использовать флаг `-race` для обнаружения состояний гонки. Например, если ваш файл называется `write.go`, команда будет выглядеть так: `go run -race write.go` или `go build -race write.go`.

При запуске этой команды Go выводит на стандартный вывод, который сообщает нам о наличии состояния гонки. Это очень полезный инструмент для обнаружения и исправления состояний гонки в ваших программах на Go.

Также стоит отметить, что состояния гонки могут быть сложными для обнаружения и воспроизведения, поскольку они могут проявляться только при определенных условиях выполнения и могут не проявляться при повторном запуске того же кода. Поэтому использование инструментов, таких как детектор состояний гонки в Go, может быть очень полезным.

## Какие есть способы устранения race condition?[​](https://golangreview.ru/docs/knowledge/golang/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/race-condition#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B5%D1%81%D1%82%D1%8C-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D1%8B-%D1%83%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-race-condition "Прямая ссылка на Какие есть способы устранения race condition?")

- Использование Mutex: (RW)Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.
- Использование каналов: Каналы в Go обеспечивают синхронизацию между горутинами и могут быть использованы для предотвращения состояний гонки.
- Использование атомарных операций: Пакет sync/atomic в Go предоставляет функции для атомарных операций, которые могут быть использованы для безопасного доступа к данным из нескольких горутин.

## Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?[​](https://golangreview.ru/docs/knowledge/golang/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/race-condition#%D0%B5%D1%81%D1%82%D1%8C-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%81%D0%BB%D0%B0%D0%B9%D1%81-%D0%B8-%D1%8F-%D0%B2-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D0%B0%D1%85-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D1%8E-%D0%B5%D0%BC%D1%83-%D0%B0%D0%BF%D0%BF%D0%B5%D0%BD%D0%B4-%D0%BA-%D0%BD%D0%B5%D0%BC%D1%83-%D0%B6%D0%B5-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BB%D0%B8-%D0%B3%D0%BE%D0%BD%D0%BA%D0%B0 "Прямая ссылка на Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?")

Да, будет состояние гонки. Функция append не является потокобезопасной, и если вы пытаетесь одновременно добавить элементы в слайс из разных горутин, это может привести к состоянию гонки.

В Go, когда вы вызываете append, он может изменить размер слайса. Если размер нового слайса больше текущей вместимости, Go создаст новый массив в памяти и скопирует в него все элементы. Если две горутины одновременно пытаются добавить элементы, они могут получить разные копии массива, что приведет к непредсказуемым результатам.

Чтобы избежать состояния гонки, вы можете использовать мьютекс (sync.Mutex или sync.RWMutex) для синхронизации доступа к слайсу.

## Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?[​](https://golangreview.ru/docs/knowledge/golang/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B8%20%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/race-condition#%D0%B5%D1%81%D1%82%D1%8C-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%81%D0%BB%D0%B0%D0%B9%D1%81-%D0%B8-%D1%8F-%D0%B2-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D0%B3%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D0%B0%D1%85-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D1%8E-%D0%B5%D0%BC%D1%83-%D0%B0%D0%BF%D0%BF%D0%B5%D0%BD%D0%B4-%D0%BA-%D0%BD%D0%B5%D0%BC%D1%83-%D0%B6%D0%B5-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BB%D0%B8-%D0%B3%D0%BE%D0%BD%D0%BA%D0%B0-1 "Прямая ссылка на Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?")

Да, будет гонка данных. В Go, горутины выполняются параллельно, и если они обе пытаются изменить одну и ту же переменную (в данном случае, глобальный слайс), это может привести к неопределенному поведению. Это известно как гонка данных.

Чтобы избежать этого, вы можете использовать мьютексы или каналы для синхронизации доступа к общим ресурсам.