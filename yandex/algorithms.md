### Структуры данных

1. **Массивы (Arrays)**:
    - **Описание**: Набор элементов, которые хранятся в непрерывном блоке памяти. Индексируются числами.
    - **Операции**: Доступ к элементам за O(1)O(1)O(1), вставка и удаление за O(n)O(n)O(n), если требуется сдвиг элементов.
    - **Применение**: Используются, когда нужно быстро получить элемент по индексу.
    ![[image2.png]]
1. **Связные списки (Linked Lists)**:
    
    - **Описание**: Последовательность узлов, где каждый узел содержит элемент данных и ссылку на следующий узел.
    - **Операции**: Вставка и удаление за O(1)O(1)O(1), доступ к элементу за O(n)O(n)O(n).
    - **Применение**: Когда важнее быстрая вставка/удаление, чем доступ к элементам.![[e1494f35d86c9ddd0c89fdee212e61f2.png]]
1. **Стек (Stack)**:
    
    - **Описание**: Структура данных с доступом по принципу "последний вошел — первый вышел" (LIFO).
    - **Операции**: Вставка и удаление элемента за O(1)O(1)O(1).
    - **Применение**: Управление вызовами функций, реализация отмены действий (undo).
    ![[0_s4dwDR8AEY-P5zHP.webp]]
1. **Очередь (Queue)**:
    
    - **Описание**: Структура данных с доступом по принципу "первый вошел — первый вышел" (FIFO).
    - **Операции**: Вставка в конец и удаление из начала за O(1)O(1)O(1).
    - **Применение**: Управление задачами, планирование процессов.
    
1. **Хэш-таблицы (Hash Tables)**:
    
    - **Описание**: Хранение пар "ключ-значение", быстрый доступ по ключу.
    - **Операции**: Поиск, вставка и удаление за O(1)O(1)O(1) в среднем случае.
    - **Применение**: Для быстрых поисков данных, создания словарей.
    
1. **Деревья (Trees)**:
    
    - **Описание**: Иерархическая структура, состоящая из узлов, где каждый узел может иметь несколько дочерних узлов.
    - **Бинарные деревья**: У каждого узла не более двух дочерних.
    - **Операции**: Поиск, вставка и удаление за O(log⁡n)O(\log n)O(logn) в сбалансированных деревьях.
    - **Применение**: Поиск, сортировка, хранение иерархий.
    
1. **Графы (Graphs)**:
    
    - **Описание**: Множество вершин и ребер между ними. Может быть направленным или ненаправленным.
    - **Операции**: Поиск пути, поиск соседей, циклы и т.д.
    - **Применение**: Социальные сети, сети дорог, схемы связей.
    

### Основные алгоритмы

1. **Сортировка**:
    
    - **Пузырьковая сортировка**: O(n2)O(n^2)O(n2), простой, но неэффективный метод.
    - **Быстрая сортировка (Quick Sort)**: O(nlog⁡n)O(n \log n)O(nlogn) в среднем случае.
    - **Сортировка слиянием (Merge Sort)**: O(nlog⁡n)O(n \log n)O(nlogn), стабилен и используется для сортировки данных.
2. **Поиск**:
    
    - **Линейный поиск**: O(n)O(n)O(n), проходит по всем элементам.
    - **Бинарный поиск**: O(log⁡n)O(\log n)O(logn), работает на отсортированных массивах.
3. **Алгоритмы на графах**:
    
    - **Поиск в глубину (DFS)**: O(V+E)O(V + E)O(V+E), используется для обхода всех вершин графа.
    - **Поиск в ширину (BFS)**: O(V+E)O(V + E)O(V+E), находит кратчайший путь в ненаправленном графе.
4. **Жадные алгоритмы (Greedy Algorithms)**:
    
    - **Принцип**: На каждом шаге выбирается локально оптимальное решение.
    - **Пример**: Алгоритм Краскала для поиска минимального остовного дерева.
5. **Динамическое программирование (Dynamic Programming)**:
    
    - **Принцип**: Разделяет задачу на подзадачи и использует результаты для их решения.
    - **Пример**: Задача о рюкзаке, последовательность Фибоначчи.